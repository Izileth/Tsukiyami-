-- Tag System
create table tags (
  id bigint generated by default as identity primary key,
  name text not null unique,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table tags enable row level security;
create policy "Tags are viewable by everyone." on tags for select using (true);
create policy "Users can create tags." on tags for insert with check (auth.role() = 'authenticated');

create table post_tags (
  post_id bigint references public.posts on delete cascade not null,
  tag_id bigint references public.tags on delete cascade not null,
  primary key (post_id, tag_id)
);

alter table post_tags enable row level security;
create policy "Post-tag relationships are viewable by everyone." on post_tags for select using (true);
create policy "Users can insert tags for their own posts." on post_tags for insert with check (
  auth.uid() = (select user_id from posts where id = post_id)
);
create policy "Users can delete tags from their own posts." on post_tags for delete using (
  auth.uid() = (select user_id from posts where id = post_id)
);

-- Update Category Policies to allow users to create categories
drop policy if exists "Admins can insert categories." on categories;
create policy "Users can create categories." on categories for insert with check (auth.role() = 'authenticated');


-- Dislike System
alter table posts
add column dislikes_count integer default 0;

create table dislikes (
  user_id uuid references public.profiles on delete cascade not null,
  post_id bigint references public.posts on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (user_id, post_id)
);

alter table dislikes enable row level security;
create policy "Users can view all dislikes." on dislikes for select using (true);
create policy "Users can insert their own dislikes." on dislikes for insert with check (auth.uid() = user_id);
create policy "Users can delete their own dislikes." on dislikes for delete using (auth.uid() = user_id);

create function public.handle_dislike_change()
returns trigger as $$
begin
  if (TG_OP = 'INSERT') then
    update public.posts set dislikes_count = dislikes_count + 1 where id = new.post_id;
  elsif (TG_OP = 'DELETE') then
    update public.posts set dislikes_count = dislikes_count - 1 where id = old.post_id;
  end if;
  return null;
end;
$$ language plpgsql security definer;

create trigger on_dislike_created
  after insert on public.dislikes
  for each row execute procedure public.handle_dislike_change();

create trigger on_dislike_deleted
  after delete on public.dislikes
  for each row execute procedure public.handle_dislike_change();


-- Comment System
create table comments (
  id bigint generated by default as identity primary key,
  post_id bigint references public.posts on delete cascade not null,
  user_id uuid references public.profiles on delete cascade not null,
  content text not null,
  parent_comment_id bigint references public.comments on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table comments enable row level security;
create policy "Comments are viewable by everyone." on comments for select using (true);
create policy "Users can insert their own comments." on comments for insert with check (auth.uid() = user_id);
create policy "Users can update their own comments." on comments for update with check (auth.uid() = user_id);
create policy "Users can delete their own comments." on comments for delete using (auth.uid() = user_id);
